# Design-Of-Algorithms-Part-1-

WELCOME: Welcome to Algorithms: Design and Analysis, Part I! The course will have six weeks of lectures and assignments, followed by a final exam. The "Syllabus" page describes the weekly topics, as well as the accompanying assignments and suggested readings. At the beginning of each week, I'll send out an email summarizing the highlights of the coming week. For the course's first week, they are as follows. 

INTRODUCTION: The first set of lectures for this week is meant to give you the flavor of the course, and hopefully get you excited about it. We begin by discussing algorithms in general and why they're so important, and then use the problem of multiplying two integers to illustrate how algorithmic ingenuity can often improve over more straightforward or naive solutions. We discuss the Merge Sort algorithm in detail, for several reasons: it's a practical and famous algorithm that you should all know; it's a good warm-up to get you ready for more intricate algorithms; and it's the canonical introduction to the "divide and conquer" algorithm design paradigm. These lectures conclude by describing several guiding principles for how we'll analyze algorithms in this course. 

ASYMPTOTIC ANALYSIS: The second set of lectures for this week is an introduction to big-oh notation and its relatives, which belongs in the vocabulary of every serious programmer and computer scientist. The goal is to identify a "sweet spot" of granularity for reasoning about algorithms --- we want to suppress second-order details like constant factors and lower-order terms, and focus on how the running time of an algorithm scales as the input size grows large. 

DIVIDE AND CONQUER ALGORITHMS: The final set of lectures for this week discusses three non-trivial examples of the divide and conquer algorithm design paradigm. The first is for counting the number of inversions in an array. This problem is related to measuring similarity between two ranked lists, which in turn is relevant for making good recommendations to someone based on your knowledge of their and others' preferences ("collaborative filtering"). The second algorithm is Strassen's mind-blowing recursive algorithm for matrix multiplication, which improves over the obvious iterative method. The third algorithm, which is more advanced and is optional material, is for computing the closest pair of points in the plane. 

PREREQUISITES: This course is not an introduction to programming, and it assumes that you have basic programming skills in a language such as Python, Java, or C.  There are several outstanding free online courses that teach basic programming.  We also use mathematical analysis as needed to understand how and why algorithms and data structures really work.  If you need a refresher on the basics of proofs (induction, contradiction, etc.), I recommend the free lecture notes "Mathematics for Computer Science" by Lehman and Leighton.

DISCUSSION FORUMS: The discussion forums play a crucial role in massive online courses like this one, which is an all-volunteer effort. If you have trouble understanding a lecture or completing an assignment, you should turn to the forums for help. After you've mastered the lectures and assignments for a given week, I hope you'll contribute to the forums and help out your fellow students. While I won't have time to carefully monitor the discussion forums, I'll check in and answer questions whenever I find the time. In previous iterations of this course, students have fostered a fantastic and supportive learning environment. 

SUPPORTING MATERIAL FOR VIDEOS: Videos can be downloaded and watched offline (recommended for commutes, etc.). In addition to the videos themselves, there are multiple versions of the lecture slides (including typed versions), as well as subtitle files (in English and in some cases other languages as well). The video speed can also be increased or decreased to accommodate your preferred pace. 

HOMEWORK (DUE JULY 19): The first problem set is out, and is due by July 19th. If you miss the deadline, you can still get 50% credit if you turn it in by the end of the course (August 30th). You'll normally receive 2 attempts for each problem set (we'll remember your best score), but to warm up with this first assignment you'll get an extra attempt. The problem set consists of 5 problems, mostly about Merge Sort and asymptotic notation. 

The first programming assignment is also out, with the same due date as the problem set. Here, we ask you to implement the counting inversions algorithm (see the third set of lectures), run it on a quite large input, and enter the answer. You can attempt each programming assignment up to 5 times. 

I really hope that you enjoy the course! 
